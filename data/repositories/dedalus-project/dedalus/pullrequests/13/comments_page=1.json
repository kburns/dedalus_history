{"pagelen": 100, "values": [{"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2015757.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2015757"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "This pull request also has a lot of attached commits to problem files and things that were merged away... it might also be easiest to make a new fork and add these changes to it, then issue a pull request from that", "markup": "markdown", "html": "<p>This pull request also has a lot of attached commits to problem files and things that were merged away... it might also be easiest to make a new fork and add these changes to it, then issue a pull request from that</p>", "type": "rendered"}, "created_on": "2014-05-30T19:27:19.464424+00:00", "user": {"display_name": "Keaton Burns", "uuid": "{3d3e64f1-bf12-45df-b655-4543d8fb34c4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D"}, "html": {"href": "https://bitbucket.org/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:e31a7835-5317-4dfa-8551-f32a06f40279/40f33f99-2b75-4a17-a8c2-07c8d74c7480/128"}}, "nickname": "kburns", "type": "user", "account_id": "557058:e31a7835-5317-4dfa-8551-f32a06f40279"}, "updated_on": "2014-05-30T19:27:19.471009+00:00", "type": "pullrequest_comment", "id": 2015757}, {"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2015805.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2015805"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "Also maybe these should be submitted as separate pull requests.  Specific comments:\n\nAntidifferentiate methods:  I'm not sure these are necessary since they can be simply replaced with LinearBVP solves which allow for much more general boundary conditions.\n\nLinearBVP change: I don't think this is correct.  The solver is setup to solve inhomogeneous linear BVPs, not nonlinear BVPs, hence the state variables should not be allowed in the RHS expressions.", "markup": "markdown", "html": "<p>Also maybe these should be submitted as separate pull requests.  Specific comments:</p>\n<p>Antidifferentiate methods:  I'm not sure these are necessary since they can be simply replaced with LinearBVP solves which allow for much more general boundary conditions.</p>\n<p>LinearBVP change: I don't think this is correct.  The solver is setup to solve inhomogeneous linear BVPs, not nonlinear BVPs, hence the state variables should not be allowed in the RHS expressions.</p>", "type": "rendered"}, "created_on": "2014-05-30T19:34:57.306127+00:00", "user": {"display_name": "Keaton Burns", "uuid": "{3d3e64f1-bf12-45df-b655-4543d8fb34c4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D"}, "html": {"href": "https://bitbucket.org/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:e31a7835-5317-4dfa-8551-f32a06f40279/40f33f99-2b75-4a17-a8c2-07c8d74c7480/128"}}, "nickname": "kburns", "type": "user", "account_id": "557058:e31a7835-5317-4dfa-8551-f32a06f40279"}, "updated_on": "2014-05-30T19:34:57.317512+00:00", "type": "pullrequest_comment", "id": 2015805}, {"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2015842.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2015842"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "Also by PEP8 standards, top-level function and class definitions should be separated by 2 blank lines.", "markup": "markdown", "html": "<p>Also by PEP8 standards, top-level function and class definitions should be separated by 2 blank lines.</p>", "type": "rendered"}, "created_on": "2014-05-30T19:40:29.450821+00:00", "user": {"display_name": "Keaton Burns", "uuid": "{3d3e64f1-bf12-45df-b655-4543d8fb34c4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D"}, "html": {"href": "https://bitbucket.org/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:e31a7835-5317-4dfa-8551-f32a06f40279/40f33f99-2b75-4a17-a8c2-07c8d74c7480/128"}}, "nickname": "kburns", "type": "user", "account_id": "557058:e31a7835-5317-4dfa-8551-f32a06f40279"}, "updated_on": "2014-05-30T19:40:29.462603+00:00", "type": "pullrequest_comment", "id": 2015842}, {"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2017351.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2017351"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "Linear BVP: That's a good point.\n\nAntidifferentiate: I think having an antidifferentiate function is significantly more practical than needing to set up linear boundary value problems.  It is true that this is essentially duplicating code from the matrix solve, but I think having an antidifferentiate function easier to work with.  Do you also think we should also remove the differentiate function (which can also be done using a linear boundary value problem)?", "markup": "markdown", "html": "<p>Linear BVP: That's a good point.</p>\n<p>Antidifferentiate: I think having an antidifferentiate function is significantly more practical than needing to set up linear boundary value problems.  It is true that this is essentially duplicating code from the matrix solve, but I think having an antidifferentiate function easier to work with.  Do you also think we should also remove the differentiate function (which can also be done using a linear boundary value problem)?</p>", "type": "rendered"}, "created_on": "2014-05-30T23:10:36.932623+00:00", "user": {"display_name": "Daniel Lecoanet", "uuid": "{0ff8d177-8703-4f25-93d4-68857e948a31}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0ff8d177-8703-4f25-93d4-68857e948a31%7D"}, "html": {"href": "https://bitbucket.org/%7B0ff8d177-8703-4f25-93d4-68857e948a31%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/829d5ddfabf278a6c21111d4de2fe031d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDL-3.png"}}, "nickname": "lecoanet", "type": "user", "account_id": "557058:ba5c14ee-54e1-4d72-aa9e-1e2a4c5ab718"}, "updated_on": "2014-05-30T23:10:36.943651+00:00", "type": "pullrequest_comment", "id": 2017351}, {"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2017424.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2017424"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "No because there's no ambiguity with what the differentiation process produces, whereas there are (infinitely) many ways to do the antiderivative, depending on whatever boundary conditions anyone wants the antiderivative to satisfy, and these methods only encode a few of them (set to zero at left or right).\n\nMaybe a good option would be to have the method simply wrap the setup and solve of a simple linear BVP, with the BC generally specified through a keyword argument.  This would retain the generality of solving as a linear BVP in the convenience of a field method.", "markup": "markdown", "html": "<p>No because there's no ambiguity with what the differentiation process produces, whereas there are (infinitely) many ways to do the antiderivative, depending on whatever boundary conditions anyone wants the antiderivative to satisfy, and these methods only encode a few of them (set to zero at left or right).</p>\n<p>Maybe a good option would be to have the method simply wrap the setup and solve of a simple linear BVP, with the BC generally specified through a keyword argument.  This would retain the generality of solving as a linear BVP in the convenience of a field method.</p>", "type": "rendered"}, "created_on": "2014-05-30T23:32:11.077758+00:00", "user": {"display_name": "Keaton Burns", "uuid": "{3d3e64f1-bf12-45df-b655-4543d8fb34c4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D"}, "html": {"href": "https://bitbucket.org/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:e31a7835-5317-4dfa-8551-f32a06f40279/40f33f99-2b75-4a17-a8c2-07c8d74c7480/128"}}, "nickname": "kburns", "type": "user", "account_id": "557058:e31a7835-5317-4dfa-8551-f32a06f40279"}, "updated_on": "2014-05-30T23:35:15.199749+00:00", "type": "pullrequest_comment", "id": 2017424}, {"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2017587.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2017587"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "Possible field-method implementation using linear bvp: https://bitbucket.org/kburns/dedalus2-kburns/src/016110d42bdedb767468aa934c2204c5d1bfc7bd/dedalus2/data/field.py?at=default#cl-177", "markup": "markdown", "html": "<p>Possible field-method implementation using linear bvp: <a href=\"https://bitbucket.org/kburns/dedalus2-kburns/src/016110d42bdedb767468aa934c2204c5d1bfc7bd/dedalus2/data/field.py?at=default#cl-177\" rel=\"nofollow\" class=\"ap-connect-link\">https://bitbucket.org/kburns/dedalus2-kburns/src/016110d42bdedb767468aa934c2204c5d1bfc7bd/dedalus2/data/field.py?at=default#cl-177</a></p>", "type": "rendered"}, "created_on": "2014-05-31T02:09:10.972299+00:00", "user": {"display_name": "Keaton Burns", "uuid": "{3d3e64f1-bf12-45df-b655-4543d8fb34c4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D"}, "html": {"href": "https://bitbucket.org/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:e31a7835-5317-4dfa-8551-f32a06f40279/40f33f99-2b75-4a17-a8c2-07c8d74c7480/128"}}, "nickname": "kburns", "type": "user", "account_id": "557058:e31a7835-5317-4dfa-8551-f32a06f40279"}, "updated_on": "2014-05-31T02:09:10.980367+00:00", "type": "pullrequest_comment", "id": 2017587}, {"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2024569.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2024569"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "I have some concerns about running a full linearBVP just to get an anti-differentiate. I absolutely agree that there are situations where that is necessary functionality, but frequently we're just talking about a constant offset.\n\nDoes Daniel's original implementation require less evaluation than this suggestion? If so, I think there's value in having it. More sophisticated users who need the full bells-and-whistles can obtain that too. Alternatively, full-bells-and-whistles could be accessed through a keyword, tripping the linearBVP approach.\n\n(apologies for duplication: did this as message to Keaton when trying to reply to comment thread)", "markup": "markdown", "html": "<p>I have some concerns about running a full linearBVP just to get an anti-differentiate. I absolutely agree that there are situations where that is necessary functionality, but frequently we're just talking about a constant offset.</p>\n<p>Does Daniel's original implementation require less evaluation than this suggestion? If so, I think there's value in having it. More sophisticated users who need the full bells-and-whistles can obtain that too. Alternatively, full-bells-and-whistles could be accessed through a keyword, tripping the linearBVP approach.</p>\n<p>(apologies for duplication: did this as message to Keaton when trying to reply to comment thread)</p>", "type": "rendered"}, "created_on": "2014-06-02T14:01:52.358928+00:00", "user": {"display_name": "Benjamin Brown", "uuid": "{7ccecdb3-3639-4001-8249-060e80320bda}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B7ccecdb3-3639-4001-8249-060e80320bda%7D"}, "html": {"href": "https://bitbucket.org/%7B7ccecdb3-3639-4001-8249-060e80320bda%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:0696c4b9-e94c-41ac-82be-62ad4f0ec571/8bc6f4da-871a-48b1-88ea-998663d18142/128"}}, "nickname": "Benjamin Brown", "type": "user", "account_id": "557058:0696c4b9-e94c-41ac-82be-62ad4f0ec571"}, "updated_on": "2014-06-02T14:01:52.366512+00:00", "type": "pullrequest_comment", "id": 2024569}, {"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2025181.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2025181"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "I agree that the current full LinearBVP isn't ideal (pencil construction can take a long time on large problems), but I really think there's a better way to approach this than repeating the recurrence relationship.  I'll work on a quick implementation of a tighter loop of solves that avoids the current Problem/Pencil overhead, which I think might still be able to include more general boundary conditions.", "markup": "markdown", "html": "<p>I agree that the current full LinearBVP isn't ideal (pencil construction can take a long time on large problems), but I really think there's a better way to approach this than repeating the recurrence relationship.  I'll work on a quick implementation of a tighter loop of solves that avoids the current Problem/Pencil overhead, which I think might still be able to include more general boundary conditions.</p>", "type": "rendered"}, "created_on": "2014-06-02T14:53:15.167996+00:00", "user": {"display_name": "Keaton Burns", "uuid": "{3d3e64f1-bf12-45df-b655-4543d8fb34c4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D"}, "html": {"href": "https://bitbucket.org/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:e31a7835-5317-4dfa-8551-f32a06f40279/40f33f99-2b75-4a17-a8c2-07c8d74c7480/128"}}, "nickname": "kburns", "type": "user", "account_id": "557058:e31a7835-5317-4dfa-8551-f32a06f40279"}, "updated_on": "2014-06-02T14:53:15.180136+00:00", "type": "pullrequest_comment", "id": 2025181}, {"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2026124.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2026124"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "Here's a second possible implementation : https://bitbucket.org/kburns/dedalus2-kburns/src/1eee85094339845859a7db417b563eb278c771bf/dedalus2/data/field.py#cl-233\n\nThis does away with the overhead of setting up a LinearBVP while still doing the same underlying solve, meaning you can have any inhomogeneous BC (left/right/int equal to any scalar or another field).  The entire evaluation (setup and all solves) takes about 2 s on a single core on my laptop for 128^3 modes, so I don't think performance should be a problem.", "markup": "markdown", "html": "<p>Here's a second possible implementation : <a href=\"https://bitbucket.org/kburns/dedalus2-kburns/src/1eee85094339845859a7db417b563eb278c771bf/dedalus2/data/field.py#cl-233\" rel=\"nofollow\" class=\"ap-connect-link\">https://bitbucket.org/kburns/dedalus2-kburns/src/1eee85094339845859a7db417b563eb278c771bf/dedalus2/data/field.py#cl-233</a></p>\n<p>This does away with the overhead of setting up a LinearBVP while still doing the same underlying solve, meaning you can have any inhomogeneous BC (left/right/int equal to any scalar or another field).  The entire evaluation (setup and all solves) takes about 2 s on a single core on my laptop for 128^3 modes, so I don't think performance should be a problem.</p>", "type": "rendered"}, "created_on": "2014-06-02T16:10:31.043517+00:00", "user": {"display_name": "Keaton Burns", "uuid": "{3d3e64f1-bf12-45df-b655-4543d8fb34c4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D"}, "html": {"href": "https://bitbucket.org/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:e31a7835-5317-4dfa-8551-f32a06f40279/40f33f99-2b75-4a17-a8c2-07c8d74c7480/128"}}, "nickname": "kburns", "type": "user", "account_id": "557058:e31a7835-5317-4dfa-8551-f32a06f40279"}, "updated_on": "2014-06-02T16:10:31.050478+00:00", "type": "pullrequest_comment", "id": 2026124}, {"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2026974.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2026974"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "The second implementation looks pretty good.  Is doing the matrix solve easier than using the recursion relations?  If so, then we should probably replace the differentiate function with something like this too.  I guess the idea is that the Diff matrix and differentiate/antidifferentiate methods are redundant.  When people make new tau bases in the future, they don't want to have to type out the same code several times (higher chance of errors...).\n\nAlso, I now remember why I think we should we should add the state variables to the evaluator dictionary for the LinearBVP.  Imagine that you solve your linear BVP, and then want to do some analysis on your solution.  For instance, you might to know the volume integrated kinetic energy.  The easiest way I can think of to do this is to create a dictionary handler, add a task which does Integrate(rho0/2*(u**2+w**2)), and then evaluate this handler.  For doing these sorts of analysis tasks, you want u and w to be in the evaluator dictionary.", "markup": "markdown", "html": "<p>The second implementation looks pretty good.  Is doing the matrix solve easier than using the recursion relations?  If so, then we should probably replace the differentiate function with something like this too.  I guess the idea is that the Diff matrix and differentiate/antidifferentiate methods are redundant.  When people make new tau bases in the future, they don't want to have to type out the same code several times (higher chance of errors...).</p>\n<p>Also, I now remember why I think we should we should add the state variables to the evaluator dictionary for the LinearBVP.  Imagine that you solve your linear BVP, and then want to do some analysis on your solution.  For instance, you might to know the volume integrated kinetic energy.  The easiest way I can think of to do this is to create a dictionary handler, add a task which does Integrate(rho0/2*(u<strong>2+w</strong>2)), and then evaluate this handler.  For doing these sorts of analysis tasks, you want u and w to be in the evaluator dictionary.</p>", "type": "rendered"}, "created_on": "2014-06-02T17:42:08.189592+00:00", "user": {"display_name": "Daniel Lecoanet", "uuid": "{0ff8d177-8703-4f25-93d4-68857e948a31}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0ff8d177-8703-4f25-93d4-68857e948a31%7D"}, "html": {"href": "https://bitbucket.org/%7B0ff8d177-8703-4f25-93d4-68857e948a31%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/829d5ddfabf278a6c21111d4de2fe031d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDL-3.png"}}, "nickname": "lecoanet", "type": "user", "account_id": "557058:ba5c14ee-54e1-4d72-aa9e-1e2a4c5ab718"}, "updated_on": "2014-06-02T17:42:08.199399+00:00", "type": "pullrequest_comment", "id": 2026974}, {"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2027390.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2027390"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "The matrix solve is really just applicable for anti-differentiation since we want the solution to simultaneously solve the ODE and some BC.  For differentiation, the options are using a recurrence-relation/wavenumber-multiplication or forward-applying the differentiation matrix (matrix multiply instead of a solve).  The recurrence relations are faster, though, so we want to have them available for RHS terms.  Now for a properly formulated first-order system, you should be able to write things in such a way as to not need the Chebyshev derivative in the RHS (and only need the transverse derivatives, i.e. wavenumber-multiplication), but we include it to give people the ability to explore different equation formulations (i.e. conservative form of the advective nonlinearity).", "markup": "markdown", "html": "<p>The matrix solve is really just applicable for anti-differentiation since we want the solution to simultaneously solve the ODE and some BC.  For differentiation, the options are using a recurrence-relation/wavenumber-multiplication or forward-applying the differentiation matrix (matrix multiply instead of a solve).  The recurrence relations are faster, though, so we want to have them available for RHS terms.  Now for a properly formulated first-order system, you should be able to write things in such a way as to not need the Chebyshev derivative in the RHS (and only need the transverse derivatives, i.e. wavenumber-multiplication), but we include it to give people the ability to explore different equation formulations (i.e. conservative form of the advective nonlinearity).</p>", "type": "rendered"}, "created_on": "2014-06-02T18:22:12.289241+00:00", "user": {"display_name": "Keaton Burns", "uuid": "{3d3e64f1-bf12-45df-b655-4543d8fb34c4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D"}, "html": {"href": "https://bitbucket.org/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:e31a7835-5317-4dfa-8551-f32a06f40279/40f33f99-2b75-4a17-a8c2-07c8d74c7480/128"}}, "nickname": "kburns", "type": "user", "account_id": "557058:e31a7835-5317-4dfa-8551-f32a06f40279"}, "updated_on": "2014-06-02T19:46:32.710006+00:00", "type": "pullrequest_comment", "id": 2027390}, {"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2027418.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2027418"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "Cool I think adding the state variables to the dict for analysis is a good idea.  In that case, they should be added to evaluator.vars after adding the RHS system handlers and tasks, so that linearity is still enforced on the ODE.", "markup": "markdown", "html": "<p>Cool I think adding the state variables to the dict for analysis is a good idea.  In that case, they should be added to evaluator.vars after adding the RHS system handlers and tasks, so that linearity is still enforced on the ODE.</p>", "type": "rendered"}, "created_on": "2014-06-02T18:25:58.847678+00:00", "user": {"display_name": "Keaton Burns", "uuid": "{3d3e64f1-bf12-45df-b655-4543d8fb34c4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D"}, "html": {"href": "https://bitbucket.org/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:e31a7835-5317-4dfa-8551-f32a06f40279/40f33f99-2b75-4a17-a8c2-07c8d74c7480/128"}}, "nickname": "kburns", "type": "user", "account_id": "557058:e31a7835-5317-4dfa-8551-f32a06f40279"}, "updated_on": "2014-06-02T18:25:58.857353+00:00", "type": "pullrequest_comment", "id": 2027418}, {"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2043363.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2043363"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "I've moved all the changes to different pull requests, except for the antidifferentiation, because we're having a bunch of discussion of that here.  I figure that once we decide on what to do with antidifferentiation, then I/Keaton can submit a new pull request for that code.", "markup": "markdown", "html": "<p>I've moved all the changes to different pull requests, except for the antidifferentiation, because we're having a bunch of discussion of that here.  I figure that once we decide on what to do with antidifferentiation, then I/Keaton can submit a new pull request for that code.</p>", "type": "rendered"}, "created_on": "2014-06-04T02:12:43.884580+00:00", "user": {"display_name": "Daniel Lecoanet", "uuid": "{0ff8d177-8703-4f25-93d4-68857e948a31}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0ff8d177-8703-4f25-93d4-68857e948a31%7D"}, "html": {"href": "https://bitbucket.org/%7B0ff8d177-8703-4f25-93d4-68857e948a31%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/829d5ddfabf278a6c21111d4de2fe031d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDL-3.png"}}, "nickname": "lecoanet", "type": "user", "account_id": "557058:ba5c14ee-54e1-4d72-aa9e-1e2a4c5ab718"}, "updated_on": "2014-06-04T02:12:43.891403+00:00", "type": "pullrequest_comment", "id": 2043363}, {"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2043550.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2043550"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "Ah yes, I now see that the differentiate method is being used to evaluate terms on the RHS.  I think that the antidifferentiate method will also sometimes be useful on the RHS.  The simplest case is that you might want to divide certain terms by the wavenumber.  But there are more complicated cases, like the buckling beam equation, where you have interesting integrals on the RHS.  Although I agree it is nice that with the matrix solve you do not need to re-implement boundary conditions, I wonder if we want to potentially sacrifice performance for this convenience.  I remember when Ben & I were running big 3D convection problems to test our scaling, I seem to remember at least one case where ~20% of the computation was in calculating dz on the RHS (comparable to dct, etc.).  At least for Fourier & Chebyshev, it is straightforward to implement any boundary condition, as it's just a matter of changing the dz=0 mode.", "markup": "markdown", "html": "<p>Ah yes, I now see that the differentiate method is being used to evaluate terms on the RHS.  I think that the antidifferentiate method will also sometimes be useful on the RHS.  The simplest case is that you might want to divide certain terms by the wavenumber.  But there are more complicated cases, like the buckling beam equation, where you have interesting integrals on the RHS.  Although I agree it is nice that with the matrix solve you do not need to re-implement boundary conditions, I wonder if we want to potentially sacrifice performance for this convenience.  I remember when Ben &amp; I were running big 3D convection problems to test our scaling, I seem to remember at least one case where ~20% of the computation was in calculating dz on the RHS (comparable to dct, etc.).  At least for Fourier &amp; Chebyshev, it is straightforward to implement any boundary condition, as it's just a matter of changing the dz=0 mode.</p>", "type": "rendered"}, "created_on": "2014-06-04T02:46:58.770273+00:00", "user": {"display_name": "Daniel Lecoanet", "uuid": "{0ff8d177-8703-4f25-93d4-68857e948a31}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0ff8d177-8703-4f25-93d4-68857e948a31%7D"}, "html": {"href": "https://bitbucket.org/%7B0ff8d177-8703-4f25-93d4-68857e948a31%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/829d5ddfabf278a6c21111d4de2fe031d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDL-3.png"}}, "nickname": "lecoanet", "type": "user", "account_id": "557058:ba5c14ee-54e1-4d72-aa9e-1e2a4c5ab718"}, "updated_on": "2014-06-04T02:46:58.776590+00:00", "type": "pullrequest_comment", "id": 2043550}, {"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2050075.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2050075"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "I think with a proper first-order formulation, we shouldn't need any explicit Chebyshev antiderivatives in the RHS, just as for Chebyshev derivatives.  Until we're working on a problem where this isn't the case, and the performance of the method is a real issue, I think we should stick with the implicit version since it requires less code, is easier to verify, and really naturally incorporates all implemented boundary conditions (including inhomogeneous values).", "markup": "markdown", "html": "<p>I think with a proper first-order formulation, we shouldn't need any explicit Chebyshev antiderivatives in the RHS, just as for Chebyshev derivatives.  Until we're working on a problem where this isn't the case, and the performance of the method is a real issue, I think we should stick with the implicit version since it requires less code, is easier to verify, and really naturally incorporates all implemented boundary conditions (including inhomogeneous values).</p>", "type": "rendered"}, "created_on": "2014-06-04T14:50:26.007048+00:00", "user": {"display_name": "Keaton Burns", "uuid": "{3d3e64f1-bf12-45df-b655-4543d8fb34c4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D"}, "html": {"href": "https://bitbucket.org/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:e31a7835-5317-4dfa-8551-f32a06f40279/40f33f99-2b75-4a17-a8c2-07c8d74c7480/128"}}, "nickname": "kburns", "type": "user", "account_id": "557058:e31a7835-5317-4dfa-8551-f32a06f40279"}, "updated_on": "2014-06-04T14:50:26.016663+00:00", "type": "pullrequest_comment", "id": 2050075}, {"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2052718.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2052718"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "As a quick note, I'm still seeing 10% cost for doing RHS dz derivatives in fully scaled out 2-D convection runs (arising from nonlinear advection of density).   At this level, the RHS dz cost is within a factor of 2 of the sparse solve. So definitely worth moving dz to implicit side at this point whenever possible. I expect that adding an additional eqn (eg, rho_z -dz(rho) = 0) will cost less in general than doing a RHS dz. I'll test this and get back to everyone. ", "markup": "markdown", "html": "<p>As a quick note, I'm still seeing 10% cost for doing RHS dz derivatives in fully scaled out 2-D convection runs (arising from nonlinear advection of density).   At this level, the RHS dz cost is within a factor of 2 of the sparse solve. So definitely worth moving dz to implicit side at this point whenever possible. I expect that adding an additional eqn (eg, rho_z -dz(rho) = 0) will cost less in general than doing a RHS dz. I'll test this and get back to everyone. </p>", "type": "rendered"}, "created_on": "2014-06-04T18:40:05.173806+00:00", "user": {"display_name": "Benjamin Brown", "uuid": "{7ccecdb3-3639-4001-8249-060e80320bda}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B7ccecdb3-3639-4001-8249-060e80320bda%7D"}, "html": {"href": "https://bitbucket.org/%7B7ccecdb3-3639-4001-8249-060e80320bda%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:0696c4b9-e94c-41ac-82be-62ad4f0ec571/8bc6f4da-871a-48b1-88ea-998663d18142/128"}}, "nickname": "Benjamin Brown", "type": "user", "account_id": "557058:0696c4b9-e94c-41ac-82be-62ad4f0ec571"}, "updated_on": "2014-06-04T18:40:05.181370+00:00", "type": "pullrequest_comment", "id": 2052718}, {"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2055192.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2055192"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "To comment on what Ben just wrote... My impression is that we can't just add extra equations like rho_z-dz(rho)=0 because we would need to add extra boundary conditions, which we don't have.  Is that right?  Or does the code realize that the rho_z-dz(rho)=0 is redundant, and not implement a boundary condition?\n\nJust to have an example to fix ideas, consider the non-dimensionalized buckling beam equation:\n\ndt^2(u) + (mu - int_0^y dy(u)*dy(u)) dy^2(u) + dy^4(u) = 0\n\nI would implement this in Dedalus as\n\n```\n#!python\n\nu_t - dt(u) = 0\nu_y - dy(u) = 0\nu_yy - dy(u_y) = 0\nu_yyy - dy(u_yy) = 0\n\ndt(u_t) + mu u_yy + dy(u_yyy) = antideriv( u_y**2 ) u_yy\n```\n\nI don't see any way to get rid of the antideriv( u_y**2 ) term.", "markup": "markdown", "html": "<p>To comment on what Ben just wrote... My impression is that we can't just add extra equations like rho_z-dz(rho)=0 because we would need to add extra boundary conditions, which we don't have.  Is that right?  Or does the code realize that the rho_z-dz(rho)=0 is redundant, and not implement a boundary condition?</p>\n<p>Just to have an example to fix ideas, consider the non-dimensionalized buckling beam equation:</p>\n<p>dt^2(u) + (mu - int_0^y dy(u)*dy(u)) dy^2(u) + dy^4(u) = 0</p>\n<p>I would implement this in Dedalus as</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"n\">u_t</span> <span class=\"o\">-</span> <span class=\"n\">dt</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"n\">u_y</span> <span class=\"o\">-</span> <span class=\"n\">dy</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"n\">u_yy</span> <span class=\"o\">-</span> <span class=\"n\">dy</span><span class=\"p\">(</span><span class=\"n\">u_y</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"n\">u_yyy</span> <span class=\"o\">-</span> <span class=\"n\">dy</span><span class=\"p\">(</span><span class=\"n\">u_yy</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n\n<span class=\"n\">dt</span><span class=\"p\">(</span><span class=\"n\">u_t</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">mu</span> <span class=\"n\">u_yy</span> <span class=\"o\">+</span> <span class=\"n\">dy</span><span class=\"p\">(</span><span class=\"n\">u_yyy</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">antideriv</span><span class=\"p\">(</span> <span class=\"n\">u_y</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"p\">)</span> <span class=\"n\">u_yy</span>\n</pre></div>\n\n\n<p>I don't see any way to get rid of the antideriv( u_y**2 ) term.</p>", "type": "rendered"}, "created_on": "2014-06-05T00:02:14.240984+00:00", "user": {"display_name": "Daniel Lecoanet", "uuid": "{0ff8d177-8703-4f25-93d4-68857e948a31}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0ff8d177-8703-4f25-93d4-68857e948a31%7D"}, "html": {"href": "https://bitbucket.org/%7B0ff8d177-8703-4f25-93d4-68857e948a31%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/829d5ddfabf278a6c21111d4de2fe031d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDL-3.png"}}, "nickname": "lecoanet", "type": "user", "account_id": "557058:ba5c14ee-54e1-4d72-aa9e-1e2a4c5ab718"}, "updated_on": "2014-06-05T00:02:14.248409+00:00", "type": "pullrequest_comment", "id": 2055192}, {"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2056309.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2056309"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "The definite integral provides the additional boundary condition, which you'd need to provide to the antiderivative operator on the RHS of that formulation.  The first-order formulation without such an operator would look like:\n\n```\n#!python\n# Equations (1 algebraic, 5 differential)\nu_t - dt(u) = 0\nu_y - dy(u) = 0\nu_yy - dy(u_y) = 0\nu_yyy - dy(u_yy) = 0\ndy(A) = u_y**2\ndt(u_t) + mu u_yy + dy(u_yyy) = A * u_yy\n\n# Plus 5 BCs: 4 original BCs on u and its derivatives, and A(y=0) = 0\n```\n", "markup": "markdown", "html": "<p>The definite integral provides the additional boundary condition, which you'd need to provide to the antiderivative operator on the RHS of that formulation.  The first-order formulation without such an operator would look like:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"c1\"># Equations (1 algebraic, 5 differential)</span>\n<span class=\"n\">u_t</span> <span class=\"o\">-</span> <span class=\"n\">dt</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"n\">u_y</span> <span class=\"o\">-</span> <span class=\"n\">dy</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"n\">u_yy</span> <span class=\"o\">-</span> <span class=\"n\">dy</span><span class=\"p\">(</span><span class=\"n\">u_y</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"n\">u_yyy</span> <span class=\"o\">-</span> <span class=\"n\">dy</span><span class=\"p\">(</span><span class=\"n\">u_yy</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"n\">dy</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">u_y</span><span class=\"o\">**</span><span class=\"mi\">2</span>\n<span class=\"n\">dt</span><span class=\"p\">(</span><span class=\"n\">u_t</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">mu</span> <span class=\"n\">u_yy</span> <span class=\"o\">+</span> <span class=\"n\">dy</span><span class=\"p\">(</span><span class=\"n\">u_yyy</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">A</span> <span class=\"o\">*</span> <span class=\"n\">u_yy</span>\n\n<span class=\"c1\"># Plus 5 BCs: 4 original BCs on u and its derivatives, and A(y=0) = 0</span>\n</pre></div>", "type": "rendered"}, "created_on": "2014-06-05T03:24:58.465221+00:00", "user": {"display_name": "Keaton Burns", "uuid": "{3d3e64f1-bf12-45df-b655-4543d8fb34c4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D"}, "html": {"href": "https://bitbucket.org/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:e31a7835-5317-4dfa-8551-f32a06f40279/40f33f99-2b75-4a17-a8c2-07c8d74c7480/128"}}, "nickname": "kburns", "type": "user", "account_id": "557058:e31a7835-5317-4dfa-8551-f32a06f40279"}, "updated_on": "2014-06-05T03:24:58.472539+00:00", "type": "pullrequest_comment", "id": 2056309}, {"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2057391.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2057391"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "Ah ha!  Good point.  I'm going to pull from your antidifferentiate, and make sure that it works as expect.  I'll also test speeds of the two methods.", "markup": "markdown", "html": "<p>Ah ha!  Good point.  I'm going to pull from your antidifferentiate, and make sure that it works as expect.  I'll also test speeds of the two methods.</p>", "type": "rendered"}, "created_on": "2014-06-05T06:46:46.817221+00:00", "user": {"display_name": "Daniel Lecoanet", "uuid": "{0ff8d177-8703-4f25-93d4-68857e948a31}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0ff8d177-8703-4f25-93d4-68857e948a31%7D"}, "html": {"href": "https://bitbucket.org/%7B0ff8d177-8703-4f25-93d4-68857e948a31%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/829d5ddfabf278a6c21111d4de2fe031d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDL-3.png"}}, "nickname": "lecoanet", "type": "user", "account_id": "557058:ba5c14ee-54e1-4d72-aa9e-1e2a4c5ab718"}, "updated_on": "2014-06-05T06:46:46.824577+00:00", "type": "pullrequest_comment", "id": 2057391}, {"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2068024.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2068024"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "I've made a new branch of my new fork for these antidifferentiate methods.  I've pulled your second method and tested it against my antidifferentiate method:\n\nhttps://bitbucket.org/lecoanet/dedalus2-lecoanet/src/7c5935837ee499c72c4089ba290eb2e22d0e28a6/dedalus2/data/field.py?at=default\n\nHere is my test script, which is based off of my script for generating backgrounds for convection + radiative zone calculations:\n\nhttps://bitbucket.org/lecoanet/examples2-lecoanet/src/cb3bc75609af8f36936b2fe1bbb1a3c5da7ff4d5/anelastic_radconv/antidifferentiate_test.py?at=default\n\nHere are what three fields returned by the antidifferentiate functions look like:\n![antidiff_S.png](data/bitbucket.org/repo/79Kayb/images/3355806960-antidiff_S.png)\n![antidiff_T.png](data/bitbucket.org/repo/79Kayb/images/893325175-antidiff_T.png)\n![antidiff_int_H_inverse.png](data/bitbucket.org/repo/79Kayb/images/923600130-antidiff_int_H_inverse.png)\n\nSo it looks like your boundary conditions are not being set quite right.  It's also possible I did not ask for the boundary conditions properly.\n\nFurthermore, it seems like the matrix solve is ~15-25 times slower on my laptop (for 128^3 problem) than the naive implementation of the integral relations.  Given that the matrix solve is so much slower, I think it makes sense to give users the option to use either the matrix solve with better boundary conditions implementation (when it works), or the faster integral relation method.  Although you could probably replace any antiderivatives in the problem formulation with derivatives (as you pointed out above), I wonder if it might be faster to calculate antiderivatives on the RHS.", "markup": "markdown", "html": "<p>I've made a new branch of my new fork for these antidifferentiate methods.  I've pulled your second method and tested it against my antidifferentiate method:</p>\n<p><a href=\"https://bitbucket.org/lecoanet/dedalus2-lecoanet/src/7c5935837ee499c72c4089ba290eb2e22d0e28a6/dedalus2/data/field.py?at=default\" rel=\"nofollow\" class=\"ap-connect-link\">https://bitbucket.org/lecoanet/dedalus2-lecoanet/src/7c5935837ee499c72c4089ba290eb2e22d0e28a6/dedalus2/data/field.py?at=default</a></p>\n<p>Here is my test script, which is based off of my script for generating backgrounds for convection + radiative zone calculations:</p>\n<p><a href=\"https://bitbucket.org/lecoanet/examples2-lecoanet/src/cb3bc75609af8f36936b2fe1bbb1a3c5da7ff4d5/anelastic_radconv/antidifferentiate_test.py?at=default\" rel=\"nofollow\" class=\"ap-connect-link\">https://bitbucket.org/lecoanet/examples2-lecoanet/src/cb3bc75609af8f36936b2fe1bbb1a3c5da7ff4d5/anelastic_radconv/antidifferentiate_test.py?at=default</a></p>\n<p>Here are what three fields returned by the antidifferentiate functions look like:\n<img alt=\"antidiff_S.png\" src=\"data/bitbucket.org/repo/79Kayb/images/3355806960-antidiff_S.png\" />\n<img alt=\"antidiff_T.png\" src=\"data/bitbucket.org/repo/79Kayb/images/893325175-antidiff_T.png\" />\n<img alt=\"antidiff_int_H_inverse.png\" src=\"data/bitbucket.org/repo/79Kayb/images/923600130-antidiff_int_H_inverse.png\" /></p>\n<p>So it looks like your boundary conditions are not being set quite right.  It's also possible I did not ask for the boundary conditions properly.</p>\n<p>Furthermore, it seems like the matrix solve is ~15-25 times slower on my laptop (for 128^3 problem) than the naive implementation of the integral relations.  Given that the matrix solve is so much slower, I think it makes sense to give users the option to use either the matrix solve with better boundary conditions implementation (when it works), or the faster integral relation method.  Although you could probably replace any antiderivatives in the problem formulation with derivatives (as you pointed out above), I wonder if it might be faster to calculate antiderivatives on the RHS.</p>", "type": "rendered"}, "created_on": "2014-06-05T23:34:18.764757+00:00", "user": {"display_name": "Daniel Lecoanet", "uuid": "{0ff8d177-8703-4f25-93d4-68857e948a31}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0ff8d177-8703-4f25-93d4-68857e948a31%7D"}, "html": {"href": "https://bitbucket.org/%7B0ff8d177-8703-4f25-93d4-68857e948a31%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/829d5ddfabf278a6c21111d4de2fe031d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDL-3.png"}}, "nickname": "lecoanet", "type": "user", "account_id": "557058:ba5c14ee-54e1-4d72-aa9e-1e2a4c5ab718"}, "updated_on": "2014-06-05T23:34:18.774134+00:00", "type": "pullrequest_comment", "id": 2068024}, {"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2068282.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2068282"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "Oops I just forgot to include the match matrices for compound bases.  Pushed the fix to my branch, and now they give identical results.  \n\nIt seems to me that Ben's results show the opposite: running the recursion for differentiation in the RHS took half as long as the full solve.  So it seems to me that properly formulating things as a first-order system gives better performance, which means that the antiderivatives would only be used in startup where small speed gains are negligible compared to generality and modularity.  ", "markup": "markdown", "html": "<p>Oops I just forgot to include the match matrices for compound bases.  Pushed the fix to my branch, and now they give identical results.  </p>\n<p>It seems to me that Ben's results show the opposite: running the recursion for differentiation in the RHS took half as long as the full solve.  So it seems to me that properly formulating things as a first-order system gives better performance, which means that the antiderivatives would only be used in startup where small speed gains are negligible compared to generality and modularity.  </p>", "type": "rendered"}, "created_on": "2014-06-06T00:27:46.408260+00:00", "user": {"display_name": "Keaton Burns", "uuid": "{3d3e64f1-bf12-45df-b655-4543d8fb34c4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D"}, "html": {"href": "https://bitbucket.org/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:e31a7835-5317-4dfa-8551-f32a06f40279/40f33f99-2b75-4a17-a8c2-07c8d74c7480/128"}}, "nickname": "kburns", "type": "user", "account_id": "557058:e31a7835-5317-4dfa-8551-f32a06f40279"}, "updated_on": "2014-06-06T00:27:46.415949+00:00", "type": "pullrequest_comment", "id": 2068282}, {"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2068691.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2068691"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "Just tested the two approaches for the buckling beam equation.  I had to implement an Antidifferentiate operator -- it's not entirely clear if I did this correctly, but presumably this doesn't affect performance much...  Here are the problem scripts:\n\nhttps://bitbucket.org/lecoanet/examples2-lecoanet/src/6c8b4602698f9251a63471012eb2f29d757552a7/antidifferentiate/buckling_beam.py?at=default\nhttps://bitbucket.org/lecoanet/examples2-lecoanet/src/6c8b4602698f9251a63471012eb2f29d757552a7/antidifferentiate/buckling_beam_diff.py?at=default\n\nConsistent with Ben's experience, the problem with the extra equation dz(A) = u_z**2 ran faster than the problem with the antidifferentiate operator on the RHS.  On my laptop, adding the extra equation make things three times faster!  I guess this suggests that the matrix version of the antidifferentiate operator is only slow due to initialization costs associated with making the matrices, etc., not due to the actual solve.\n\nWell now I'm convinced that it's better to implement the antidifferentiate method by doing a matrix solve.  Keaton, do you just want to make a pull request for that, and I'll close this pull request?", "markup": "markdown", "html": "<p>Just tested the two approaches for the buckling beam equation.  I had to implement an Antidifferentiate operator -- it's not entirely clear if I did this correctly, but presumably this doesn't affect performance much...  Here are the problem scripts:</p>\n<p><a href=\"https://bitbucket.org/lecoanet/examples2-lecoanet/src/6c8b4602698f9251a63471012eb2f29d757552a7/antidifferentiate/buckling_beam.py?at=default\" rel=\"nofollow\" class=\"ap-connect-link\">https://bitbucket.org/lecoanet/examples2-lecoanet/src/6c8b4602698f9251a63471012eb2f29d757552a7/antidifferentiate/buckling_beam.py?at=default</a>\n<a href=\"https://bitbucket.org/lecoanet/examples2-lecoanet/src/6c8b4602698f9251a63471012eb2f29d757552a7/antidifferentiate/buckling_beam_diff.py?at=default\" rel=\"nofollow\" class=\"ap-connect-link\">https://bitbucket.org/lecoanet/examples2-lecoanet/src/6c8b4602698f9251a63471012eb2f29d757552a7/antidifferentiate/buckling_beam_diff.py?at=default</a></p>\n<p>Consistent with Ben's experience, the problem with the extra equation dz(A) = u_z**2 ran faster than the problem with the antidifferentiate operator on the RHS.  On my laptop, adding the extra equation make things three times faster!  I guess this suggests that the matrix version of the antidifferentiate operator is only slow due to initialization costs associated with making the matrices, etc., not due to the actual solve.</p>\n<p>Well now I'm convinced that it's better to implement the antidifferentiate method by doing a matrix solve.  Keaton, do you just want to make a pull request for that, and I'll close this pull request?</p>", "type": "rendered"}, "created_on": "2014-06-06T02:05:06.846145+00:00", "user": {"display_name": "Daniel Lecoanet", "uuid": "{0ff8d177-8703-4f25-93d4-68857e948a31}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0ff8d177-8703-4f25-93d4-68857e948a31%7D"}, "html": {"href": "https://bitbucket.org/%7B0ff8d177-8703-4f25-93d4-68857e948a31%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/829d5ddfabf278a6c21111d4de2fe031d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDL-3.png"}}, "nickname": "lecoanet", "type": "user", "account_id": "557058:ba5c14ee-54e1-4d72-aa9e-1e2a4c5ab718"}, "updated_on": "2014-06-06T02:05:06.853982+00:00", "type": "pullrequest_comment", "id": 2068691}, {"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2068789.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2068789"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "Sounds good.  Thanks for writing up these tests and catching that bug in the matrix implementation!", "markup": "markdown", "html": "<p>Sounds good.  Thanks for writing up these tests and catching that bug in the matrix implementation!</p>", "type": "rendered"}, "created_on": "2014-06-06T02:26:08.595012+00:00", "user": {"display_name": "Keaton Burns", "uuid": "{3d3e64f1-bf12-45df-b655-4543d8fb34c4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D"}, "html": {"href": "https://bitbucket.org/%7B3d3e64f1-bf12-45df-b655-4543d8fb34c4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:e31a7835-5317-4dfa-8551-f32a06f40279/40f33f99-2b75-4a17-a8c2-07c8d74c7480/128"}}, "nickname": "kburns", "type": "user", "account_id": "557058:e31a7835-5317-4dfa-8551-f32a06f40279"}, "updated_on": "2014-06-06T02:26:08.601749+00:00", "type": "pullrequest_comment", "id": 2068789}], "page": 1, "size": 23}