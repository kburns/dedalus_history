{"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2068691.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2068691"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "Just tested the two approaches for the buckling beam equation.  I had to implement an Antidifferentiate operator -- it's not entirely clear if I did this correctly, but presumably this doesn't affect performance much...  Here are the problem scripts:\n\nhttps://bitbucket.org/lecoanet/examples2-lecoanet/src/6c8b4602698f9251a63471012eb2f29d757552a7/antidifferentiate/buckling_beam.py?at=default\nhttps://bitbucket.org/lecoanet/examples2-lecoanet/src/6c8b4602698f9251a63471012eb2f29d757552a7/antidifferentiate/buckling_beam_diff.py?at=default\n\nConsistent with Ben's experience, the problem with the extra equation dz(A) = u_z**2 ran faster than the problem with the antidifferentiate operator on the RHS.  On my laptop, adding the extra equation make things three times faster!  I guess this suggests that the matrix version of the antidifferentiate operator is only slow due to initialization costs associated with making the matrices, etc., not due to the actual solve.\n\nWell now I'm convinced that it's better to implement the antidifferentiate method by doing a matrix solve.  Keaton, do you just want to make a pull request for that, and I'll close this pull request?", "markup": "markdown", "html": "<p>Just tested the two approaches for the buckling beam equation.  I had to implement an Antidifferentiate operator -- it's not entirely clear if I did this correctly, but presumably this doesn't affect performance much...  Here are the problem scripts:</p>\n<p><a href=\"https://bitbucket.org/lecoanet/examples2-lecoanet/src/6c8b4602698f9251a63471012eb2f29d757552a7/antidifferentiate/buckling_beam.py?at=default\" rel=\"nofollow\" class=\"ap-connect-link\">https://bitbucket.org/lecoanet/examples2-lecoanet/src/6c8b4602698f9251a63471012eb2f29d757552a7/antidifferentiate/buckling_beam.py?at=default</a>\n<a href=\"https://bitbucket.org/lecoanet/examples2-lecoanet/src/6c8b4602698f9251a63471012eb2f29d757552a7/antidifferentiate/buckling_beam_diff.py?at=default\" rel=\"nofollow\" class=\"ap-connect-link\">https://bitbucket.org/lecoanet/examples2-lecoanet/src/6c8b4602698f9251a63471012eb2f29d757552a7/antidifferentiate/buckling_beam_diff.py?at=default</a></p>\n<p>Consistent with Ben's experience, the problem with the extra equation dz(A) = u_z**2 ran faster than the problem with the antidifferentiate operator on the RHS.  On my laptop, adding the extra equation make things three times faster!  I guess this suggests that the matrix version of the antidifferentiate operator is only slow due to initialization costs associated with making the matrices, etc., not due to the actual solve.</p>\n<p>Well now I'm convinced that it's better to implement the antidifferentiate method by doing a matrix solve.  Keaton, do you just want to make a pull request for that, and I'll close this pull request?</p>", "type": "rendered"}, "created_on": "2014-06-06T02:05:06.846145+00:00", "user": {"display_name": "Daniel Lecoanet", "uuid": "{0ff8d177-8703-4f25-93d4-68857e948a31}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0ff8d177-8703-4f25-93d4-68857e948a31%7D"}, "html": {"href": "https://bitbucket.org/%7B0ff8d177-8703-4f25-93d4-68857e948a31%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/829d5ddfabf278a6c21111d4de2fe031d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDL-3.png"}}, "nickname": "lecoanet", "type": "user", "account_id": "557058:ba5c14ee-54e1-4d72-aa9e-1e2a4c5ab718"}, "updated_on": "2014-06-06T02:05:06.853982+00:00", "type": "pullrequest_comment", "id": 2068691}