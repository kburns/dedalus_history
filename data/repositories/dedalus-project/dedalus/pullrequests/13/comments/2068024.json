{"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2068024.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2068024"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "I've made a new branch of my new fork for these antidifferentiate methods.  I've pulled your second method and tested it against my antidifferentiate method:\n\nhttps://bitbucket.org/lecoanet/dedalus2-lecoanet/src/7c5935837ee499c72c4089ba290eb2e22d0e28a6/dedalus2/data/field.py?at=default\n\nHere is my test script, which is based off of my script for generating backgrounds for convection + radiative zone calculations:\n\nhttps://bitbucket.org/lecoanet/examples2-lecoanet/src/cb3bc75609af8f36936b2fe1bbb1a3c5da7ff4d5/anelastic_radconv/antidifferentiate_test.py?at=default\n\nHere are what three fields returned by the antidifferentiate functions look like:\n![antidiff_S.png](data/bitbucket.org/repo/79Kayb/images/3355806960-antidiff_S.png)\n![antidiff_T.png](data/bitbucket.org/repo/79Kayb/images/893325175-antidiff_T.png)\n![antidiff_int_H_inverse.png](data/bitbucket.org/repo/79Kayb/images/923600130-antidiff_int_H_inverse.png)\n\nSo it looks like your boundary conditions are not being set quite right.  It's also possible I did not ask for the boundary conditions properly.\n\nFurthermore, it seems like the matrix solve is ~15-25 times slower on my laptop (for 128^3 problem) than the naive implementation of the integral relations.  Given that the matrix solve is so much slower, I think it makes sense to give users the option to use either the matrix solve with better boundary conditions implementation (when it works), or the faster integral relation method.  Although you could probably replace any antiderivatives in the problem formulation with derivatives (as you pointed out above), I wonder if it might be faster to calculate antiderivatives on the RHS.", "markup": "markdown", "html": "<p>I've made a new branch of my new fork for these antidifferentiate methods.  I've pulled your second method and tested it against my antidifferentiate method:</p>\n<p><a href=\"https://bitbucket.org/lecoanet/dedalus2-lecoanet/src/7c5935837ee499c72c4089ba290eb2e22d0e28a6/dedalus2/data/field.py?at=default\" rel=\"nofollow\" class=\"ap-connect-link\">https://bitbucket.org/lecoanet/dedalus2-lecoanet/src/7c5935837ee499c72c4089ba290eb2e22d0e28a6/dedalus2/data/field.py?at=default</a></p>\n<p>Here is my test script, which is based off of my script for generating backgrounds for convection + radiative zone calculations:</p>\n<p><a href=\"https://bitbucket.org/lecoanet/examples2-lecoanet/src/cb3bc75609af8f36936b2fe1bbb1a3c5da7ff4d5/anelastic_radconv/antidifferentiate_test.py?at=default\" rel=\"nofollow\" class=\"ap-connect-link\">https://bitbucket.org/lecoanet/examples2-lecoanet/src/cb3bc75609af8f36936b2fe1bbb1a3c5da7ff4d5/anelastic_radconv/antidifferentiate_test.py?at=default</a></p>\n<p>Here are what three fields returned by the antidifferentiate functions look like:\n<img alt=\"antidiff_S.png\" src=\"data/bitbucket.org/repo/79Kayb/images/3355806960-antidiff_S.png\" />\n<img alt=\"antidiff_T.png\" src=\"data/bitbucket.org/repo/79Kayb/images/893325175-antidiff_T.png\" />\n<img alt=\"antidiff_int_H_inverse.png\" src=\"data/bitbucket.org/repo/79Kayb/images/923600130-antidiff_int_H_inverse.png\" /></p>\n<p>So it looks like your boundary conditions are not being set quite right.  It's also possible I did not ask for the boundary conditions properly.</p>\n<p>Furthermore, it seems like the matrix solve is ~15-25 times slower on my laptop (for 128^3 problem) than the naive implementation of the integral relations.  Given that the matrix solve is so much slower, I think it makes sense to give users the option to use either the matrix solve with better boundary conditions implementation (when it works), or the faster integral relation method.  Although you could probably replace any antiderivatives in the problem formulation with derivatives (as you pointed out above), I wonder if it might be faster to calculate antiderivatives on the RHS.</p>", "type": "rendered"}, "created_on": "2014-06-05T23:34:18.764757+00:00", "user": {"display_name": "Daniel Lecoanet", "uuid": "{0ff8d177-8703-4f25-93d4-68857e948a31}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0ff8d177-8703-4f25-93d4-68857e948a31%7D"}, "html": {"href": "https://bitbucket.org/%7B0ff8d177-8703-4f25-93d4-68857e948a31%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/829d5ddfabf278a6c21111d4de2fe031d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDL-3.png"}}, "nickname": "lecoanet", "type": "user", "account_id": "557058:ba5c14ee-54e1-4d72-aa9e-1e2a4c5ab718"}, "updated_on": "2014-06-05T23:34:18.774134+00:00", "type": "pullrequest_comment", "id": 2068024}