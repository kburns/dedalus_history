{"links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13/comments/2043550.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13/_/diff#comment-2043550"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 13, "links": {"self": {"href": "data/repositories/dedalus-project/dedalus/pullrequests/13.json"}, "html": {"href": "#!/dedalus-project/dedalus/pull-requests/13"}}, "title": "WIP: Eigenvalue solver; antidifferentiate methods; mid-domain BC"}, "content": {"raw": "Ah yes, I now see that the differentiate method is being used to evaluate terms on the RHS.  I think that the antidifferentiate method will also sometimes be useful on the RHS.  The simplest case is that you might want to divide certain terms by the wavenumber.  But there are more complicated cases, like the buckling beam equation, where you have interesting integrals on the RHS.  Although I agree it is nice that with the matrix solve you do not need to re-implement boundary conditions, I wonder if we want to potentially sacrifice performance for this convenience.  I remember when Ben & I were running big 3D convection problems to test our scaling, I seem to remember at least one case where ~20% of the computation was in calculating dz on the RHS (comparable to dct, etc.).  At least for Fourier & Chebyshev, it is straightforward to implement any boundary condition, as it's just a matter of changing the dz=0 mode.", "markup": "markdown", "html": "<p>Ah yes, I now see that the differentiate method is being used to evaluate terms on the RHS.  I think that the antidifferentiate method will also sometimes be useful on the RHS.  The simplest case is that you might want to divide certain terms by the wavenumber.  But there are more complicated cases, like the buckling beam equation, where you have interesting integrals on the RHS.  Although I agree it is nice that with the matrix solve you do not need to re-implement boundary conditions, I wonder if we want to potentially sacrifice performance for this convenience.  I remember when Ben &amp; I were running big 3D convection problems to test our scaling, I seem to remember at least one case where ~20% of the computation was in calculating dz on the RHS (comparable to dct, etc.).  At least for Fourier &amp; Chebyshev, it is straightforward to implement any boundary condition, as it's just a matter of changing the dz=0 mode.</p>", "type": "rendered"}, "created_on": "2014-06-04T02:46:58.770273+00:00", "user": {"display_name": "Daniel Lecoanet", "uuid": "{0ff8d177-8703-4f25-93d4-68857e948a31}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0ff8d177-8703-4f25-93d4-68857e948a31%7D"}, "html": {"href": "https://bitbucket.org/%7B0ff8d177-8703-4f25-93d4-68857e948a31%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/829d5ddfabf278a6c21111d4de2fe031d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDL-3.png"}}, "nickname": "lecoanet", "type": "user", "account_id": "557058:ba5c14ee-54e1-4d72-aa9e-1e2a4c5ab718"}, "updated_on": "2014-06-04T02:46:58.776590+00:00", "type": "pullrequest_comment", "id": 2043550}